'use client'

import { useState, useRef, useEffect } from 'react'
import { ZoomIn, ZoomOut, RotateCcw, Move } from 'lucide-react'

interface Product3DViewerProps {
  imageUrl: string
  productName: string
}

export default function Product3DViewer({ imageUrl, productName }: Product3DViewerProps) {
  const [rotateY, setRotateY] = useState(0)
  const [rotateX, setRotateX] = useState(0)
  const [zoom, setZoom] = useState(1)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const containerRef = useRef<HTMLDivElement>(null)

  // 마우스 드래그로 회전
  const handleMouseDown = (e: React.MouseEvent) => {
    setIsDragging(true)
    setDragStart({ x: e.clientX - rotateY, y: e.clientY - rotateX })
  }

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging) return
    setRotateY(e.clientX - dragStart.x)
    setRotateX(e.clientY - dragStart.y)
  }

  const handleMouseUp = () => {
    setIsDragging(false)
  }

  // 마우스 휠로 줌
  const handleWheel = (e: React.WheelEvent) => {
    e.preventDefault()
    const delta = e.deltaY > 0 ? -0.1 : 0.1
    setZoom(prev => Math.max(0.5, Math.min(3, prev + delta)))
  }

  // 터치 이벤트 (모바일)
  useEffect(() => {
    if (!containerRef.current) return

    let touchStart = { x: 0, y: 0 }
    let initialDistance = 0

    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        touchStart = { 
          x: e.touches[0].clientX - rotateY, 
          y: e.touches[0].clientY - rotateX 
        }
      } else if (e.touches.length === 2) {
        initialDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        )
      }
    }

    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        setRotateY(e.touches[0].clientX - touchStart.x)
        setRotateX(e.touches[0].clientY - touchStart.y)
      } else if (e.touches.length === 2 && initialDistance > 0) {
        const currentDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        )
        const scale = currentDistance / initialDistance
        setZoom(prev => Math.max(0.5, Math.min(3, prev * scale)))
        initialDistance = currentDistance
      }
    }

    const element = containerRef.current
    element.addEventListener('touchstart', handleTouchStart)
    element.addEventListener('touchmove', handleTouchMove)

    return () => {
      element.removeEventListener('touchstart', handleTouchStart)
      element.removeEventListener('touchmove', handleTouchMove)
    }
  }, [rotateX, rotateY])

  const resetView = () => {
    setRotateX(0)
    setRotateY(0)
    setZoom(1)
  }

  return (
    <div className="relative">
      {/* 3D 뷰어 */}
      <div 
        ref={containerRef}
        className="relative aspect-square rounded-xl overflow-hidden bg-neutral-50"
        style={{ perspective: '1000px' }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
      >
        <div 
          className="w-full h-full transition-transform duration-100 ease-out"
          style={{
            transform: `rotateX(${-rotateX * 0.3}deg) rotateY(${rotateY * 0.3}deg) scale(${zoom})`,
            transformStyle: 'preserve-3d',
            cursor: isDragging ? 'grabbing' : 'grab'
          }}
        >
          <img 
            src={imageUrl}
            alt={productName}
            className="w-full h-full object-cover select-none"
            draggable={false}
          />
        </div>

        {/* 안내 텍스트 */}
        <div className="absolute bottom-4 left-4 bg-black/50 text-white px-3 py-1 rounded-full text-xs flex items-center gap-2">
          <Move className="w-3 h-3" />
          드래그로 회전 • 스크롤로 확대
        </div>
      </div>

      {/* 컨트롤 버튼 */}
      <div className="flex items-center justify-center gap-3 mt-4">
        <button 
          onClick={() => setZoom(Math.max(0.5, zoom - 0.3))}
          className="p-2 bg-white rounded-full shadow hover:shadow-md transition-shadow"
        >
          <ZoomOut className="w-4 h-4" />
        </button>
        
        <div className="px-3 py-1 bg-neutral-100 rounded-full text-sm">
          {(zoom * 100).toFixed(0)}%
        </div>
        
        <button 
          onClick={() => setZoom(Math.min(3, zoom + 0.3))}
          className="p-2 bg-white rounded-full shadow hover:shadow-md transition-shadow"
        >
          <ZoomIn className="w-4 h-4" />
        </button>
        
        <button 
          onClick={resetView}
          className="p-2 bg-neutral-900 text-white rounded-full shadow hover:bg-neutral-800 transition-colors"
        >
          <RotateCcw className="w-4 h-4" />
        </button>
      </div>

      {/* 각도 프리셋 버튼 */}
      <div className="flex items-center justify-center gap-2 mt-3">
        <button 
          onClick={() => { setRotateY(0); setRotateX(0) }}
          className="px-3 py-1 text-xs bg-neutral-100 rounded-full hover:bg-neutral-200"
        >
          정면
        </button>
        <button 
          onClick={() => { setRotateY(-120); setRotateX(0) }}
          className="px-3 py-1 text-xs bg-neutral-100 rounded-full hover:bg-neutral-200"
        >
          좌측 45°
        </button>
        <button 
          onClick={() => { setRotateY(120); setRotateX(0) }}
          className="px-3 py-1 text-xs bg-neutral-100 rounded-full hover:bg-neutral-200"
        >
          우측 45°
        </button>
      </div>
    </div>
  )
}
